Linux 命令：
	cd 
	pwd    :显示当前路径
	ls         -a -l
			例如： ls -al Music //显示Music的完整信息
	mkdir  //横向创建文件
				mkdir xx yy zz tt
				mkdir -p //纵向创建文件
	touch 
			    touch 1.c 2.c
	cp
	mv
	rm
==================
vim
![[vim.png]]

命令模式：5yy:从光标数开始复制五行
5dd：从光标处删除五行
底行模式：
：wq! //强制保存退出
插入模式：o//往后新建一个一行
				a//到光标后面输入
				i//到光标前面输入
==================
姿势：
		命令 \[选项们]\[参数们]
		括号代表可有可无
		选项们 ： 都是以 - 开头
==================
c语言：（高级货）
	c语言就要通过指针访问内存地址，从而操作硬件
![[1698631341774.png]]

===================================
int a = 10;
unsigned int b = 50;
b = 20;
b + 1 = 30;//错误，过程是cpu从内存中取出30和1在cpu中进行运算，并将结果存储在cpu的某处，所以结果不在内存中。
		问题出在 `b + 1 = 30;` 这条语句上。在 C/C++ 中，赋值操作符 `=` 的左边必须是一个可修改的左值，但 `b + 1` 并不是一个可修改的左值，因为它是一个表达式的结果。

==============================================
常量：
		程序实行过程中，你不会改变的量
变量：
		程序执行过程中，可以发生变化的量
类型：
		决定变量的存储空间大小的（属性）
等号：
		赋值符号：将等号右边的值赋值给等号左边的内存空间
		
======================================
类型：
	\*基本类型 ：short int long long long float double
	\*指针类型 ： 
	\*构造类型 ：数组、结构体、联合体
	\*空类型     ：void
======================================
基本类型：
	1.整型 ：
			整型常量：
					八进制（0） 十进制 十六进制（0x/0X)  //二进制(0b/0B)
			整型变量：
					\*定义变量（short float  int)
					short s;//在内存中占用2个字节空间，该控件命名为s
					\*赋值：
						要做赋值操作的前提：必须要有空间
								a = 10;//将等号右边的值10赋值给等号左边的内存空间a，但前提是空间已经创建。
						\*初始化：
							在定义变量的同时赋值：
									short xx = 20;
						\*存储：
							原码 反码 补码
							原码： 人看的码
							反码： 机器看的
							补码： 构建原码和补码的桥梁
						正数：
								原码 = 反码 = 补码
						负数：
								反码 = 原码 符号位不变，其他全部取反
								补码 = 反码+1
						例子：
							short s =12;
							s中如何存储：(只有整型有)
										原码： 00000000 00001100
										反码： 00000000 00001100
										补码： 00000000 00001100  //s的存储
						short ss = -12;
										原码： 10000000 00001100
										反码： 11111111 11110011
										补码： 11111111 11110100 //ss中的存储
				看到补码 ：1110011 10110011（内存中）
						反码 ：11110011 10110010
						原码： 10001100 01001101（人看的） ：-3149
=====================						=====================
变量名字：
		\*有 数字 字符（区分大小写）  下划线组成
		\*不能以数字开头，最好不要以下划线开头
		\*名字取名要有意义  int age;
		\*名字不能太长（不能超过63个）
		\*不能使用关键字（系统已经赋予含义的子：int short float）
		
============================
2.浮点型：
		常量：
		   12.5     le3 #e的前后得有数据 e的后面不能有小数
 float double
		定义变量：
			float xx,yy,zz,tt；//同时定义
				 赋值：
				 xx = 12.5;
				初始化:
				float ff =12.5 , dd = 25.6;
存储格式：
						float 32位：
						\*1个符号位       0正数    1负数
						\*8个指数位      01111111 ： 指数0（规定的）
						\*23个小数位 
01111111  : 0
10000000  : 1
10000001  : 2
10000010  : 3	
10001001  : 10
							float f =1254.625;
				1. 先变成二进制：
							整数部分除以 2 逆向取余
							例如： 1254 ：  10011100110
							小数部分乘以2正向取整
									0.625 ：  0.101
					1254.625 \=》 10011100110.101 -->1.0011100110101\*2^10
				f ： 0 10001001 00111001101010000000000 
				有疑问：第一个0是什么？第二个是指数位 剩下的是小数位
				解答：第一个零就是符号位，当时觉得疑惑是因为算出来的结果开头是1不是0；
确定符号位：符号位位于二进制表示的最高位。根据IEEE 754标准，如果浮点数是正数，则符号位为0；如果浮点数是负数，则符号位为1。
    对于f = 1254.625，它是一个正数，因此符号位为0。


double d = -1254.625；  64位
	一个符号位
	11个指数位 01111111111 ：指数0
	52个小数位
01111111110 : -1				
01111111111 : 0
10000000000 : 1
10000000001 : 2
10000000010 : 3
10000000011 : 4
10000000100 : 5
10000000101 : 6
10000000110 : 7
10000000111 : 8
10000001000 : 9
10000001001 : 10


3.字符型：
		常量：
			'a'  '\\n' '\\a'
			八进制字符常量： '\\ddd' ：d是八进制  例子： '\\123' -->本质是='S'
十六进制字符常量： '\\xdd' :  d是十六进制 例子：'\\x21' -->本质是 = '!'
man ascii

变量：
	char c = 'a';
	char d = '\\x21';

=================================================
===========================================
char :  -128 ~ 127
unsigned char : 0 ~ 255
short :  -32768  ~ 32767
unsigned short : 0 ~ 65535
int : -21亿 ~ 21亿 
unsigned int : 0 ~ 42亿 


浮点型的指数位全为1，则代表无穷大
float 范围：
	1符号位，8个指数位 23小数位
	最大值：
		符号位： 0
		指数位： 11111110  
		小数位： 1111111111111111111111
		1.1111111111111111111111 * 2 ^ 127  ~~ 2^128
		
float 的取值范围 ： -2^128  ~ 2^128
		
01111111 : 0
10000000 : 1
11111110 : 127
			
9.999999999 * 10^2  ~~ 10^3	

double 范围：
	1符号位，11个指数位 52小数位
	最大值：
		符号位： 0
		指数位： 11111111110  
		小数位： 1111111111111111111111.....
		1.1111111111111111111111... * 2^1023 ~~ 2^1024

==========================================	
double 类型取值范围 -2^1024 ~ 2^1024
float 的取值范围 ： -2^128  ~ 2^128


=============================================
整型：
		短整型 short
		整型     int
		长整型  long long long
		
=================================================
任意整型数字都是int类型
		10 ： int类型
		0x1234 ： int类型
		
任意浮点型数字都是double 类型
		12.5 : double
		11e3: double
		
==========================
====================
内存中只存储数据，不做任何处理 
	10001100 11000101 00111100 11000000

00111100 11000000（系统取到了这两个字节做分析加工 ） \===\》 \给人看
11000101 
10001100 11000101 00111100 11000000

=================================================
基本类型： 既可以自动转换，也能强制转换（高低精度之间的转换）
	char --- unsigned char ---- short --- unsigned short --- int --- unsigned int --- long --- unsigned long --- long long  --- unsigned long long --- float --- double --- long double 
基本类型之间的转换 非常自由

==========================
等号两边类型一定要一致 才能做 赋值 操作 

short s = 10; //在内存中占用2个字节空间，该空间命名为s，cpu将 int类型的 10 自动转换为 short 类型的 10 存入到 s 中 

int i = 12.9; // 断尾操作 12.9 ---》 12

float f = 12.5;
float ff = 12.5f; // 12.5f 就是 float类型

long l = 10; // int 10 变成 long 类型 10 存入到 l中 
long ll = 20L; // 20L 就是 long 类型的 20
long long llx = 32LL; 32LL 就是 long long 类型的 32

unsigned int ui = 52U;   52U : unsigned int 类型 52
unsigned long ul = 20UL;  20UL : unsigned long 类型的20

f/F    : float
u/U    : unsigned 
l/L    : long 

======
小于int类型的整型进行的运算，都要转换成为 int 进行运算 
	short s = 12; //在内存中占用2个字节空间，该空间命名为s ，CPU将 int 12 自动转换为 short 12 存入s 中
	char c = 10;//在内存中占用1个字节空间，该空间命名为c，CPU将 int 10 自动转换为 char 10 存入c中
	s + c; // 将s的值取出来 转变为 int 类型 存入 cpu寄存器中
	       //将c的值取出来 转变为 int 类型 存入 cpu寄存器中
		   // cpu将2个 int 类型做 运算，得到  int 类型 22 存入 cpu寄存器中 
		   
======
同类型数据进行运算，得到同类型 
	1 / 2  ===>  0
	
======
运算时，高低精度都有，低精度会自动变成高精度 
	short s = 10;
	long l = 20L;
	s + l ; 

=================================================
printf
sacnf 
		printf: 打印：
		printf("xxxxxxx");  //只打印双引号里面的东西 
		int a = 10;
		printf("%hd",a);   // 10
		short s = 20;
		printf("%d\n",s);
		h : half 一半
		%d   :   以 int 方式打印 
		%hd  :   以 short 方式打印 
		%hhd ：以 char 方式 打印 //它会以有符号的整数形式打印出ASCII码值
		%u   :   以 unsigned int 方式打印 
		%hu  :   以 unsigned short 方式打印 
		%hhu ：  以 unsigned char 方式 打印 		
		%#x   :   以 int 的 16进制打印
		%#hx  ：  以 short 的 16进制打印
		%#hhx  ：  以 char 的 16进制打印
		.........
		
		
==========================
int a;
scanf("%d",&a);
	scanf的第二个参数： 数据要存放的内存空间的地址 

==========================
